
package com.sun.jbi.snmpbc.engine.test;

import com.sun.jdmk.tasks.DaemonTaskServer;
import com.sun.management.snmp.SnmpEngineId;
import com.sun.management.snmp.SnmpEventReportDispatcher;
import com.sun.management.snmp.SnmpPduRequest;
import com.sun.management.snmp.SnmpPduTrap;
import com.sun.management.snmp.SnmpScopedPduRequest;
import com.sun.management.snmp.SnmpVarBind;
import com.sun.management.snmp.manager.SnmpSession;
import com.sun.management.snmp.manager.SnmpTrapListener;
import com.sun.soabi.snmpbc.traps.Trap;
import com.sun.soabi.snmpbc.traps.Traps;
import com.sun.soabi.snmpbc.traps.VarBinding;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;

import java.io.ByteArrayOutputStream;

/**
 * The class shows how to: <br> - use the OidTable generated by mibgen <br> -
 * write and use an SnmpRequestHandler <br> - deal with asynchronous requests
 * <br> - listen to traps sent by an agent
 */

public class AsyncManager {

    public class TrapListenerImpl implements SnmpTrapListener {

        public void processSnmpTrapV1(SnmpPduTrap trap) {
            println("NOTE: TrapListenerImpl received trap :");
            println("\tGeneric " + trap.genericTrap);
            println("\tSpecific " + trap.specificTrap);
            println("\tTimeStamp " + trap.timeStamp);
            println("\tAgent adress " + trap.agentAddr.stringValue());
            for (int i = 0; i < trap.varBindList.length; i++) {
                SnmpVarBind b = trap.varBindList[i];
                println("\t" + i + ":OID " + b.getOid().toString());
                println("\t" + i + ":value " + b.getStringValue());
            } 

            Trap t = new Trap();
            t.setRequestID(trap.requestId);
            if (trap.address != null) {
                t.setUDPSource(trap.address.toString());
            }
            t.setUDPPort(Integer.valueOf(trap.port));
            t.setType(trap.type);
            for (int i = 0; i < trap.varBindList.length; i++) {
                SnmpVarBind b = trap.varBindList[i];

                t.getValues().add(new VarBinding());
                t.getValues().get(i).setOID(b.getOid().toString());
                t.getValues().get(i).setType(-1);
                t.getValues().get(i).setValue(b.getStringValue());
            } 
            
            Traps traps = new Traps();
            traps.getTrap().add(t);

            
            ByteArrayOutputStream out = new ByteArrayOutputStream();

            try {
                Thread.currentThread().setContextClassLoader(AsyncManager.class.getClassLoader());
                
                JAXBContext jaxbContext = JAXBContext.newInstance("com.sun.soabi.snmpbc.traps");
                Marshaller marshaller = jaxbContext.createMarshaller();
                marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,
                    new Boolean(true));
                marshaller.marshal(traps, out);
                println(out.toString());
            } catch (Throwable e) {
                e.printStackTrace();
            }
/*
            try {
                prod.send(sess1.createTextMessage(out.toString()));
            } catch (JMSException e) {
                e.printStackTrace();
            }
 */
        }

        public void processSnmpTrapV2(SnmpPduRequest trap) {
            println("NOTE: Trap V2 not of interest !!!");
        }

        public void processSnmpTrapV3(SnmpScopedPduRequest trap) {
            println("NOTE: TrapListenerImpl received trap V3:");
            println("\tContextEngineId : "
                + SnmpEngineId.createEngineId(trap.contextEngineId));
            println("\tContextName : " + new String(trap.contextName));
            println("\tVarBind list :");
            for (int i = 0; i < trap.varBindList.length; i++)
                println("oid : " + trap.varBindList[i].getOid() + " val : "
                    + trap.varBindList[i].getSnmpValue());

        }

        /**
         * print/println stuff...
         */

        private final void println(String msg) {
            java.lang.System.out.println(msg);
        }
    }
    
    
    private SnmpSession session;
    private SnmpEventReportDispatcher trapAgent ;
    private DaemonTaskServer taskServer;
/*
    private QueueConnection con1;
    private QueueSession sess1;
    private QueueSender prod;
 */
    
    public void start() {

        final String port = "5540"; // minus one

        try {
/*
            com.sun.messaging.QueueConnectionFactory fact1 = new com.sun.messaging.QueueConnectionFactory();
            fact1.setProperty("imqBrokerHostName", "localhost");
            fact1.setProperty("imqBrokerHostPort", "7676");
            fact1.setProperty("imqConnectionType", "TCP");
            
            con1 = fact1.createQueueConnection("admin", "admin");
            sess1 = con1.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
            Queue dest1 = sess1.createQueue("DefaultQueue");
            prod = sess1.createSender(dest1);
            con1.start();
*/
            // Build the session. A session creates, controls and manages
            // one or more requests.
            session = new SnmpSession("AsyncManager session");

            // Create a taskServer for processing traps.
            // This is an optional step. However using a DaemonTaskServer
            // to process incomming PDUs makes it possible to empty
            // the trap socket faster, thus reducing the hazards
            // of trap loss.
            // We set the priority of the DaemonTaskServer to
            // Thread.NORM_PRIORITY so that emptying the socket takes
            // precedence over trap processing.
            //
            taskServer = new DaemonTaskServer();
            taskServer.start(Thread.NORM_PRIORITY);

            // Create a listener and dispatcher for SNMP traps
            // (SnmpEventReportDispatcher).
            // SnmpEventReportDispatcher is run as a thread and listens
            // for traps in UDP port = agent port + 1.
            trapAgent = new SnmpEventReportDispatcher(
                Integer.parseInt(port) + 1, null, taskServer, null);
            System.out.println(trapAgent.getEngine());
            trapAgent.addTrapListener(new TrapListenerImpl());
            final Thread trapThread = new Thread(trapAgent);
            trapThread.setPriority(Thread.MAX_PRIORITY);
            trapThread.start();
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }
    
    public void stop() {
        session.destroySession();

        try {
            trapAgent.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        try {
            taskServer.terminate();
        } catch (Exception e) {
            e.printStackTrace();
        }
/*
        try {
            con1.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
*/
    }

    public static void main(String argv[]) {
        try {
            AsyncManager a = new AsyncManager();
            a.start();
            println("\n>> Press <Enter> if you want to stop" + " this SNMP manager.\n");
            java.lang.System.in.read();
            a.stop();
        } catch (Throwable e) {
            e.printStackTrace();
        }
            
//            // Create an SnmpPeer object for representing the entity
//            // to communicate with.
//            final SnmpPeer agent = new SnmpPeer("localhost", Integer.parseInt(port));
//
//            // Create parameters to associate to the entity to
//            // communicate with.
//            // When creating the parameter object, you can specify the
//            // read and write community to be used when querying the agent.
//            final SnmpParameters params = new SnmpParameters("public", "private");
//
//            // The newly created parameter must be associated to the agent.
//            agent.setParams(params);
//
//            // Build the session. A session creates, controls and manages
//            // one or more requests.
//            final SnmpSession session = new SnmpSession("AsyncManager session");
//
//            // A default peer (agent) can be associated to a SnmpSession.
//            // When invoking a service provided by the SnmpSession, if
//            // the agent is not specified, the session will perform
//            // the service using the default peer as the target of the
//            // service.
//            //
////            session.setDefaultPeer(agent);
//
//            // Create a taskServer for processing traps.
//            // This is an optional step. However using a DaemonTaskServer
//            // to process incomming PDUs makes it possible to empty
//            // the trap socket faster, thus reducing the hazards
//            // of trap loss.
//            // We set the priority of the DaemonTaskServer to
//            // Thread.NORM_PRIORITY so that emptying the socket takes
//            // precedence over trap processing.
//            //
//            final DaemonTaskServer taskServer = new DaemonTaskServer();
//            taskServer.start(Thread.NORM_PRIORITY);
//
//            // Create a listener and dispatcher for SNMP traps
//            // (SnmpEventReportDispatcher).
//            // SnmpEventReportDispatcher is run as a thread and listens
//            // for traps in UDP port = agent port + 1.
//            final SnmpEventReportDispatcher trapAgent = new SnmpEventReportDispatcher(
//                Integer.parseInt(port) + 1, null, taskServer, null);
//            trapAgent.addTrapListener(new TrapListenerImpl());
//            final Thread trapThread = new Thread(trapAgent);
//            trapThread.setPriority(Thread.MAX_PRIORITY);
//            trapThread.start();
//
//
//            println("\n>> Press <Enter> if you want to stop" + " this SNMP manager.\n");
//            java.lang.System.in.read();
//
//            // Nicely stop the session
//            //
//            session.destroySession();
//
//            // Nicely stop the SnmpEventReportDispatcher.
//            //
//            trapAgent.close();
//            taskServer.terminate();

//        } catch (Exception e) {
//            java.lang.System.err.println("AsyncManager::main: " + "Exception occurred:"
//                + e);
//            e.printStackTrace();
//        }
    }

    private final static void println(String msg) {
        java.lang.System.out.println(msg);
    }
}
