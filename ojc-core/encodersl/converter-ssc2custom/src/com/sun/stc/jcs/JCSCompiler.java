/*
 * BEGIN_HEADER - DO NOT EDIT
 * 
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the "License").  You may not use this file except
 * in compliance with the License.
 *
 * You can obtain a copy of the license at
 * https://open-jbi-components.dev.java.net/public/CDDLv1.0.html.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * HEADER in each file and include the License file at
 * https://open-jbi-components.dev.java.net/public/CDDLv1.0.html.
 * If applicable add the following below this CDDL HEADER,
 * with the fields enclosed by brackets "[]" replaced with
 * your own identifying information: Portions Copyright
 * [year] [name of copyright owner]
 */

/*
 * @(#)JCSCompiler.java 
 *
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * END_HEADER - DO NOT EDIT
 */

package com.sun.stc.jcs;

import java.io.*;

import com.sun.stc.jcsre.ETDConstants;
import com.sun.stc.jcsre.JCSProperties;
import com.sun.stc.jcsre.xml.SAX2Writer;

import java.util.*;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import java.lang.reflect.*;

// For writing JAR files.
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.Date;

public class JCSCompiler extends com.sun.stc.compilers.Compiler
{
    public static final int NONE = 0;
    public static final int OPTIONAL = NONE+1;
    public static final int ZEROMANY = OPTIONAL+1;
    public static final int ONEMANY = ZEROMANY+1;
    public static final int FIXED = ONEMANY+1;
    public static final int IMPLIED= FIXED+1;
    public static final int REQUIRED = IMPLIED+1;

    protected String packageName = null;
    protected ContentHandler xscHandler;
    protected PrintStream xscStream;
    protected XscWriter   xscWriter;
    protected int xscUid = 0;
    
    protected String VECTOR = "java.util.Vector";

    private static final String NUMERIC_TYPES = "byte"
                                                + ",short"
                                                + ",int"
                                                + ",long"
                                                + ",float"
                                                + ",double"
                                                ;

    private static final String PRIMITIVE_TYPES = NUMERIC_TYPES
                                                + ",boolean"
                                                + ",char"
                                                ;

    public static String normalSafe(String s) {
	return com.sun.stc.jcs.ssc.SscConv.sscNormal(s);
    }

    public void setUseArrayList(boolean value) {
	if(value) {
	    VECTOR = "java.util.ArrayList";
	} else {
	    VECTOR = "java.util.Vector";
	}
    }
    
    Hashtable _properties = new Hashtable();
    
    public Object getProperty(String key) {
	return _properties.get(key);
    }

    public void setProperty(String key, Object value) {
	_properties.put(key, value);
    }

    public JCSCompiler()
    {
    }

    // These are the names of classes that are imported by source code
    // generated by Antlr (www.antlr.org).
    private static final String[] antlrNames = 
    {
        "TokenBuffer", "TokenStreamException", "TokenStreamIOException",
	"ANTLRException", "LLkParser", "Token", "TokenStream",
	"RecognitionException", "NoViableAltException", "MismatchedTokenException",
	"SemanticException", "ParserSharedInputState", "BitSet",
	"AST", "ASTPair", "ASTArray"
    };
    protected static final java.util.Set antlrNamesSet = new java.util.HashSet();
    static 
    {
        for (int i = 0; i < antlrNames.length;i++) 
        {
            antlrNamesSet.add(antlrNames[i]);
        }
    }

    // added by Lixin because some X12 Segment names are conflicted with our stuff
    private static final String[] otherReservedNames =
    {
        "ETD"
    };
    protected static final java.util.Set otherReservedNamesSet = new java.util.HashSet();
    static 
    {
        for (int i = 0; i < otherReservedNames.length;i++) 
        {
            otherReservedNamesSet.add(otherReservedNames[i].toUpperCase());
        }
    }

    // See http://support.microsoft.com/support/kb/articles/Q216/6/54.ASP why
    // we need to keep track of these.
    private static final String[] dosDeviceNames = 
    {
        "CON", "PRN", "AUX", "CLOCK$", "NUL",
        "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
        "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"
    };
    protected static final java.util.Set dosDeviceNamesSet = new java.util.HashSet();
    static 
    {
        for (int i = 0; i < dosDeviceNames.length;i++) 
        {
            dosDeviceNamesSet.add(dosDeviceNames[i].toUpperCase());
        }
    }

    // http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#229308
    private static final String[] keywords = 
    {
        "abstract", "boolean", "break", "byte", "byvalue", "case",
        "cast", "catch", "char", "class", "const", "continue",
        "default", "do", "double", "else", "extends", "false",
        "final", "finally", "float", "for", "future", "generic",
        "goto", "if", "implements", "import", "inner", "instanceof",
        "int", "interface", "long", "native", "new", "null",
        "operator", "outer", "package", "private", "protected", "public",
        "rest", "return", "short", "static", "strictfp", "super", "switch",
        "synchronized", "this", "throw", "throws", "transient", "true",
        "try", "var", "void", "volatile", "while"
    };
    protected static final java.util.Set keywordSet = new java.util.HashSet();
    static 
    {
        for (int i = 0; i < keywords.length;i++) 
        {
            keywordSet.add(keywords[i]);
        }
    }

    // 56123
    // we need to keep track of names in java.lang package.
    private static final String[] javaLangNames = 
    {
        "String", "System", "Boolean", "Byte", "Character",
        "Class", "ClassLoader", "Compiler", "Double", "Float",
        "Integer", "Long", "Math", "Number", "Object", "Package",
        "Process", "Runtime", "RuntimePermission", "SecurityManager",
        "StrictMath", "Short", "StringBuffer", "Thread",
        "ThreadGroup", "ThreadLocal", "Throwable", "Void", 
        "CharSequence", "Cloneable", "Comparable", "Runnable" 
    };
    
    protected static final java.util.Set javaLangNameSet = new java.util.HashSet();
    static 
    {
        for (int i = 0; i < javaLangNames.length;i++) 
        {
            javaLangNameSet.add(javaLangNames[i]);
        }
    }
    // 56123 end
    
    public static String makeEnumName(String enu) 
    {
        String result = makeJavaName(enu).toUpperCase();
        if (Character.isDigit(result.charAt(0))) 
        {
            return "_" + result;
        }
        return result;
    }

    public static String makeClassName(String name) 
    {
        String result = makeJavaName(name);
        if (Character.isDigit(result.charAt(0))) {
            return "_" + result;
        }
        /*if(keywordSet.contains(result)) {
            result = result + "_";
	    } else */
	if(dosDeviceNamesSet.contains(result.toUpperCase())) {
            result = result + "_";
        } else if(antlrNamesSet.contains(result)) {
	    result = result + "_";
	} else if (otherReservedNamesSet.contains(result)) { // added by Lixin
	    result = result + "_";
	} 
        // 56123        
        else if (javaLangNameSet.contains(result.substring(0, 1).toUpperCase()+result.substring(1,result.length()))) {
            result = result + "_";
        }         
        // end 56123
	result = result.substring(0, 1).toUpperCase() + result.substring(1);
        return result;
    }

    public static String makeJavaName(String name) 
    {
        name = name.trim();
        int size = name.length();
        char[] ncChars = name.toCharArray();
        int next = 0;
        
        boolean uppercase = false;
        
        for (int i = 0; i < size; i++) 
        {
            char ch = ncChars[i];
            if (!Character.isDigit(ch) &&
                ((ch == '_') ||
                 (next == 0 && !Character.isJavaIdentifierStart(ch)) ||
                 next > 0 && !Character.isJavaIdentifierPart(ch))) 
            {
                if (next == 0 ||
                    Character.isDigit(ncChars[next -1]) ||
                    Character.isUpperCase(ncChars[next-1])||
                    (ch == '_'))  
                {
                    ncChars[next++] = '_';
                }
                else 
                {
                    uppercase = true;
                }
                continue;
            }
            else if (ch == ' ') 
            {
                ncChars[next] = '_';
                uppercase = false;
            }
            else if (uppercase) 
            {
                ncChars[next] = Character.toUpperCase(ch);
                uppercase = false;
            }
            else 
            {
                ncChars[next] = ch;
            }
            ++next;
        }
        return new String(ncChars, 0, next);
    }
    
    // javaName must have come from makeJavaName()
    public static String makeBeanName(String javaName) 
    {
        int pos = 0;
        String beanName =  javaName.substring(pos, pos +1).toUpperCase() + javaName.substring(pos+1);
        // Cannot override final getClass() in java.lang.object.
        if (beanName.equals("Class")) beanName = beanName + "_";
        return beanName;
    }

    // Generate a rule name for ANTLR [www.antlr.org].
    // className must have come from makeClassName() or makeJavaName()
    public static String makeRuleName(String className) 
    {
        String ruleName = className.replace('$', '_');
        return ruleName.substring(0, 1).toLowerCase() + ruleName.substring(1);
    }

    // The method used here to determine the enumeration value should be exactly the
    // same used in processEnumeration. Currently, it's the index into the item list.
    public String getDefaultEnumValue(String[] items, String defaultValue) 
    {
        for (int i = 0; i < items.length; i++) 
        {
            if (items[i].equals(defaultValue)) 
            {
                return ""+i;
            }
        }
        return null;
    }

    // Validate a package name.
    public static boolean isValidPackageName(String name) 
    {
        java.util.StringTokenizer tokens = new java.util.StringTokenizer(name, ".");
        if (tokens.countTokens() == 0) 
        {
            return false;
        }
        while (tokens.hasMoreTokens()) 
        {
            String token = tokens.nextToken();
            if (keywordSet.contains(token)) 
            {
                return false;
            }
            char[] chars = token.toCharArray();
            int size = chars.length;
            if ((size == 0) || (!Character.isJavaIdentifierStart(chars[0]))) 
            {
                return false;
            }
            else 
            {
                for (int i = 1; i < size; i++) 
                {
                    if (!Character.isJavaIdentifierPart(chars[i])) 
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    }
    
    // Generate a valid package name.
    public static String makePackageName(String name)
    {
        if (isValidPackageName(name))
        {
            return name;
        }
        StringTokenizer st = new StringTokenizer(name, ".");
        String retName = null;
        while (st.hasMoreTokens())
        {
            if (null == retName)
            {
                retName = makeJavaName(st.nextToken());
            }
            else
            {
                retName = retName + "." + makeJavaName(st.nextToken());
            }
        }
        return retName;
    }

    // Given a set of currently-used names, generate a new unique name that is
    // not in the set.
    public static String getUniqueName(String name, Hashtable usedNames) 
    {
        String suffix = "";
        while (usedNames.containsKey(name+suffix)) 
        {
            suffix += "_";
        }
        return name+suffix;
    }

    // This is used for generating unique class names -- Microsoft DOS/Windows file names are
    // case-insensitive so we cannot have case-sensitive class names.
    public static String getUniqueNameIgnoreCase(String name, Hashtable usedNames) 
    {
        String suffix = "";
        String tempName = name.toUpperCase();
        while (true) 
        {
            Enumeration e = usedNames.keys();
            boolean foundDup = false;
            while (e.hasMoreElements()) 
            {
                String compareName = ((String)e.nextElement()).toUpperCase();
                if (compareName.equals(tempName+suffix)) 
                {
                    foundDup = true;
                    break;
                }
            }
            if (foundDup) 
            {
                suffix += "_";
            }
            else 
            {
                return name+suffix;
            }
        }
    }

    // *****************************************************************
    //
    // I18N stuff
    //
    //******************************************************************

    /** Make Java string literal. */
    // Copied from makeStringLiteral in ssc.JGen.
    protected String makeJavaStringLiteral(String value) {
	StringBuffer buf = new StringBuffer(value.length() + 2);
	buf.append("\"");
	for (int i = 0, len = value.length(); i < len; i++) {
	    char ch = value.charAt(i);
	    switch (ch) {
		// The usual special cases.
	    case '\b': buf.append("\\b");  break;
	    case '\n': buf.append("\\n");  break;
	    case '\r': buf.append("\\r");  break;
	    case '\t': buf.append("\\t");  break;
	    case '\\': buf.append("\\\\"); break;
	    case '\"': buf.append("\\\""); break;
	    default:
		if('\u0020' <= ch && ch <= '\u007E') {
		    // Not printable: use 2-digit hex escape.
		    buf.append(ch);
		} else {
		    // Unprintable or non-ASCII: do 4 hex-digit Unicode escape.
		    buf.append("\\u");
		    for (int n = 12; n >= 0; n -= 4)
			buf.append("0123456789ABCDEF".charAt((ch >> n) & 0xF));
		    continue;
		}
	    }
	}
	buf.append("\"");
	return buf.toString();
    }

    /** ANTLR names are like C identifiers, only ASCII alphanumeric
     * and underscore.  This maps a generic Unicode string by escaping
     * "_" ans "__", and the rest as "_u" + 4-digit hex charcode.
     */
    protected String makeAntlrEscapedName(String name)
    {
	int len = name.length();
	StringBuffer b = new StringBuffer(len);
	boolean esc = false;
	for (int i = 0; i < len; i ++)
	{
	    char c = name.charAt(i);
	    if (('a' <= c && c <= 'z') ||
		('A' <= c && c <= 'Z') ||
		('0' <= c && c <= '9'))
	    {
		// Stays the same: a-z, A-Z, 0-9.
		if (esc && c != 'u') b.append('_');
		b.append(c);
		esc = false;
	    }
	    else if (c == '_')
	    {
		// Escaped.
		b.append("__");
	    }
	    else
	    {
		// Transform rest to Unicode-escape.
		b.append("_u");
		for (int sh = 12; sh >= 0; sh -= 4)
		    b.append("0123456789ABCDEF".charAt((c >> sh) & 0xF));
		esc = true;
	    }
	}
	return b.toString();
    }


    //******************************************************************
    //
    // CODE GENERATION
    //
    //******************************************************************
    public void processEnumeration(String indent,
                                   String enumName,
                                   String[] items,
                                   int card)
        throws SAXException
    {
        String javaName = makeJavaName(enumName);
        String cName = makeClassName(enumName);
        String tagName = "node";

        emit(indent, "public static class "+cName+" {");

        AttributesImpl attrs = new AttributesImpl();
        attrs.addAttribute("", "name", "name", "CDATA", normalSafe(cName));
        attrs.addAttribute("", "type", "type", "CDATA", "ENUMERATION");
        attrs.addAttribute("", "uid", "uid", "CDATA", ""+xscUid++);

        if (items.length > 0) 
        {
            if ( xscHandler != null )
                xscHandler.startElement("", tagName, tagName, attrs);
            for (int i = 0;i < items.length;i++) 
            {
                emit(indent+TAB, "public static final int "+makeEnumName(items[i])+" = "+i+";");
                AttributesImpl attrs1 = new AttributesImpl();
                //attrs1.addAttribute("", "name", "name", "CDATA", makeEnumName(items[i]));
                attrs1.addAttribute("", "name", "name", "CDATA", normalSafe(items[i]));
                attrs1.addAttribute("", "type", "type", "CDATA", "int");
                attrs1.addAttribute("", "value", "value", "CDATA", ""+i);
                attrs1.addAttribute("", "uid", "uid", "CDATA", ""+xscUid++);
                if ( xscHandler != null )
                    ((SAX2Writer)xscHandler).emptyElement("", "node", "node", attrs1);
            }
            if ( xscHandler != null )
                xscHandler.endElement("", tagName, tagName);
        }
        else 
        {
            if ( xscHandler != null )
                ((SAX2Writer)xscHandler).emptyElement("", tagName, tagName, attrs);
        }

        emit(indent, "}");
        if (card == REQUIRED) 
        {
            emit(indent, "private int _" + javaName +";");
        }
        else 
        {
            emit(indent, "private java.lang.Integer _" + javaName +";");
        }
    }
    
    // name | boxed-value |initializer| accessor
    protected final String[] primitives = new String[] {

        "boolean", "java.lang.Boolean", "(false)", ".booleanValue()",
        "byte", "java.lang.Byte", "((byte)0)", ".byteValue()",
        "char", "java.lang.Character", "('\\0')", ".charValue()",
        "short", "java.lang.Short",  "((short)0)", ".shortValue()",
        "int", "java.lang.Integer", "(0)", ".intValue()",
        "long", "java.lang.Long", "(0)", ".longValue()",
        "float", "java.lang.Float", "(0)", ".floatValue()",
        "double", "java.lang.Double", "(0)", ".doubleValue()",
        "java.math.BigInteger", "java.math.BigInteger", "(\"0\")", "",
        "java.math.BigDecimal", "java.math.BigDecimal", "(\"0\")", "",
        "byte[]", null, "{}", "",
        "char[]", null, "{}", ""
    };

    // LT added
    public void processClassAccessors(PrintStream ps, String indent, String javaType, String javaName, 
        String beanName, int card)
    {
        setOut(ps);
        processClassAccessors(indent, javaType, javaName, beanName, card);     
    }
    // LT added
    public void processClassAccessors(PrintStream ps, String indent, String javaType, String javaName, 
        String beanName, int card, boolean readOnly)
    {
        setOut(ps);
        processClassAccessors(indent, javaType, javaName, beanName, card, readOnly);     
    }
    
    public void processClassAccessors(String indent, String javaType, 
                                      String javaName, String beanName,
                                      int card) {
        processClassAccessors(indent, javaType, javaName, beanName, card, false);
    }

    public void processClassAccessors(String indent, String javaType, 
                                      String javaName, String beanName,
                                      int card, boolean readOnly) {
	processClassAccessors(indent, javaType, javaName, beanName, card, readOnly, false, null);
    }

    public void processClassAccessors(String indent, String javaType, 
                                      String javaName, String beanName,
                                      int card, boolean readOnly,
				      boolean isChoice, String omitAll) {
	processClassAccessors(indent, javaType, javaName, beanName, card,
			      readOnly, isChoice, omitAll, false);
    }

    public void processClassAccessors(String indent, String javaType, 
                                      String javaName, String beanName,
                                      int card, boolean readOnly,
				      boolean isChoice, String omitAll,
				      boolean nillable) {
        String initType = javaType;
        emit(indent, "public "+javaType+" get"+beanName+"() {");
        String init = "()";
        String boxedType = null;
        String accessor = "";
        boolean primitive = false;
        for(int i = 0; i < primitives.length; i += 4) {
            if(javaType.equals(primitives[i])) {
                primitive = true;
		if(card == OPTIONAL) {
		    boxedType = primitives[i + 1];
		    if(boxedType != null) {
			initType = boxedType;
		    }
		    accessor = primitives[i + 3];
		}
		init = primitives[i + 2];
                break;
            }
        }
        if (!primitive || card == OPTIONAL) {
	    if(isChoice && (omitAll != null)) {
		emit(indent+TAB, "if (_"+javaName+" == null) {"+omitAll+" _"+javaName+" = new "+initType+""+init+";}");
	    } else {
		emit(indent+TAB, "if (_"+javaName+" == null) _"+javaName+" = new "+initType+""+init+";");
	    }
        }
        emit(indent+TAB, "return _"+javaName+accessor+";");
        emit(indent, "}");
        if(!readOnly) {
            emit(indent, "public void set"+beanName+"("+javaType+" val) {");
	    if(isChoice && (omitAll != null)) {
		emit(indent+TAB, "if(_"+javaName+" == null) {" + omitAll + "}");
	    }
            if(boxedType != null && accessor.length() > 0) {
                emit(indent+TAB, "_"+javaName+" = new "+boxedType+"(val);");
            } else {
                emit(indent+TAB, "_"+javaName+" = val;");
            }
            emit(indent, "}");
        }
        if (card == OPTIONAL || isChoice) 
        {
	    emit(indent, "public boolean has"+beanName+"() {");
	    emit(indent+TAB, "return _"+javaName+" != null;");
	    emit(indent, "}");
            if(!readOnly && !isChoice) {
                emit(indent, "public void omit"+beanName+"() {");
                emit(indent+TAB, "_"+javaName+" = null;");
                emit(indent, "}");
            }
        }
	if(nillable) {
	    emit(indent, "public boolean nil"+beanName+"() {");
	    emit(indent+TAB, "return _nil_"+javaName+";");
	    emit(indent, "}");
	    emit(indent, "public void nil"+beanName+"(boolean value) {");
	    emit(indent+TAB, "get"+beanName+"();");
	    emit(indent+TAB, "_nil_"+javaName+"=value;");
	    emit(indent, "}");
	}
        emit("", "");
    }
    
    public void processClassAccessorsFixed(String indent, String javaType, String javaName, String beanName, String value) {
        emit(indent, "// get a fixed value");
        emit(indent, "public " + javaType + " get" + beanName + "() {");
        emit(indent+TAB, "return _" + javaName + ";");
        emit(indent, "}");
        emit(indent, "// set - do nothing because value is fixed");
        emit(indent, "public void set" + beanName + "(" + javaType + " val) {");
        emit(indent, "}");
    }

    public void processPrimitiveTypeAccessors(String indent, String javaType,
        String javaName, String beanName, int card) {
        processClassAccessors(indent, javaType, javaName, beanName, card);
    }

    public void processEnumAccessors(String indent, String javaName, 
                                     String beanName, int card)
    {
        if (card == OPTIONAL) 
        {
            emit(indent, "public int get"+beanName+"() {");
            emit(indent+TAB, "return _"+javaName+ ".intValue();");
            emit(indent, "}");
            emit(indent, "public void set"+beanName+"(int val) {");
            emit(indent+TAB, "_"+javaName+" = new Integer(val);");
            emit(indent, "}");
            emit(indent, "public boolean has"+beanName+"() {");
            emit(indent+TAB, "return _"+javaName+" != null;");
            emit(indent, "}");
            emit(indent, "public void omit"+beanName+"() {");
            emit(indent+TAB, "_"+javaName+" = null;");
            emit(indent, "}");
        }
        else 
        {
            emit(indent, "public int get"+beanName+"() {");
            emit(indent+TAB, "return _"+javaName+";");
            emit(indent, "}");
            emit(indent, "public void set"+beanName+"(int val) {");
            emit(indent+TAB, "_"+javaName+" = val;");
            emit(indent, "}");
        }
    }
    // LT added
    public void processCollectionAccessors(PrintStream ps, String indent, String javaType, String javaName, 
        String beanName)
    {
        setOut(ps);
        processCollectionAccessors(indent, javaType, javaName, beanName);
    }
    // LT added
    public void processCollectionAccessors(PrintStream ps, String indent, String javaType, String javaName, 
        String beanName, boolean readOnly)
    {
        setOut(ps);
        processCollectionAccessors(indent, javaType, javaName, beanName, readOnly);
    }
    
    public void processCollectionAccessors(String indent, String javaType, String javaName, String beanName) {
        processCollectionAccessors(indent, javaType, javaName, beanName, false, false, null);
    }

    public void processCollectionAccessors(String indent, String javaType, String javaName, String beanName, boolean readOnly) {
	processCollectionAccessors(indent, javaType, javaName, beanName, readOnly, false, null);
    }

    public void processCollectionAccessors(String indent, String javaType, String javaName, String beanName, boolean readOnly, boolean isChoice, String omitAll)
    {
	processCollectionAccessors(indent, javaType, javaName, beanName,
				   readOnly, isChoice, omitAll, false);
    }

    public void processCollectionAccessors(String indent, String javaType, String javaName, String beanName, boolean readOnly, boolean isChoice, String omitAll, boolean nillable)
    {
        String init = "()";
        String castType = javaType;
        String boxedType = null;
        String accessor = "";
        for(int i = 0; i < primitives.length; i += 4) {
            if(javaType.equals(primitives[i])) {
                boxedType = primitives[i + 1];
                castType = boxedType;
                init = primitives[i + 2];
                
                //esr 57288
                if (!isPrimitiveType(castType)) {
                    init = "(_" + javaName + ".get(0).toString())";
                }
                
                accessor = primitives[i + 3];
                break;
            }
        }
        emit(indent, "public "+javaType+" get"+beanName+"(int i) {");
	if(isChoice && (omitAll != null)) {
	    emit(indent+TAB, "if(_" + javaName + ".size() == 0) {"+omitAll+"}");
	}
	emit(indent+TAB, "if (i == _"+javaName+".size()) _"+javaName+".add(new "+castType+""+init+");");
        emit(indent+TAB, "return (("+castType+") _"+javaName+".get(i))"+accessor+";");
        emit(indent, "}");

        if(!readOnly) {
            // set(index, value)
            emit(indent, "public void set"+beanName+"(int i, "+javaType+" val) {");

            //esr 57288 added the following codes, esr 75363 removed them
            //if (isPrimitiveType(javaType)) {
            //    emit(indent+TAB, "if (val == 0) {get"+beanName+"(i);return;}"); 
            //} else {
            //    emit(indent+TAB, "if (val == null) {get"+beanName+"(i);return;}"); 
            //}
            
	    if(isChoice && (omitAll != null)) {
		emit(indent+TAB, "if(_" + javaName + ".size() == 0) {"+omitAll+"}");
	    }
            if(boxedType != null && accessor.length() > 0) {
                emit(indent+TAB, "if (i == _"+javaName+".size()) _"+javaName+
                     ".add(new "+boxedType+"(val));");
                emit(indent+TAB, "else _"+javaName+".set(i, new "+boxedType+"(val));");
            } else {
                emit(indent+TAB, "if (i == _"+javaName+".size()) _"+javaName+
                     ".add(val); else _"+javaName+".set(i, val);");
            }
            emit(indent, "}");
        }

        // get
        emit(indent, "public "+javaType+"[] get"+beanName+"() {");
	if(isChoice && (omitAll != null)) {
	    emit(indent+TAB, "if(_" + javaName + ".size() == 0) {"+omitAll+"}");
	}
        emit(indent+TAB, javaType+"[] tmp = new "+javaType+"[_"+javaName+".size()];");
        if(boxedType != null && accessor.length() > 0) {
            emit(indent+TAB, "for(int i = 0, len = _"+javaName+".size(); i < len; i++) tmp[i] = (("+boxedType+")_"+javaName+".get(i))"+accessor+";");
        } else {
            emit(indent+TAB, "_"+javaName+".toArray(tmp);");
        }
        emit(indent+TAB, "return tmp;");
        emit(indent, "}");

        if(!readOnly) {
            // set(value[])
            emit(indent, "public void set"+beanName+"("+javaType+" [] val) {");
	    if(isChoice && (omitAll != null)) {
		emit(indent+TAB, "if(_" + javaName + ".size() == 0) {"+omitAll+"}");
	    }
            emit(indent+TAB, "_"+javaName+" = new "+VECTOR+"(val.length);");
            if(boxedType != null && accessor.length() > 0) {
                emit(indent+TAB, "for(int i = 0; i < val.length; i++) _"+javaName+".add(new "+boxedType+"(val[i]));");
            } else {
                emit(indent+TAB, "for(int i = 0; i < val.length; i++) _"+javaName+".add(val[i]);");
            }
            emit(indent, "}");
        }

        // count
        emit(indent, "public int count"+beanName+"() {");
        emit(indent+TAB, "return _"+javaName+".size();");
        emit(indent, "}");
	
	if(isChoice) {
	    //has
	    emit(indent, "public boolean has"+beanName+"() {");
	    emit(indent+TAB, "return _"+javaName+ ".size() > 0;");
	    emit(indent, "}");
	}
	    
        if(!readOnly) {

            // remove
            emit(indent, "public void remove"+beanName+"(int index) {");
            emit(indent+TAB, "_"+javaName+".remove(index);");
            emit(indent, "}");
            
            // add(value)
            emit(indent, "public void add"+beanName+"("+javaType+" value) {");
	    if(isChoice && (omitAll != null)) {
		emit(indent+TAB, "if (_" + javaName + ".size() == 0) {" + omitAll +"}");
	    }
            if(boxedType != null && accessor.length() > 0) {
                emit(indent+TAB, "_"+javaName+".add(new "+boxedType+"(value));");
            } else {
                emit(indent+TAB, "_"+javaName+".add(value);");
            }
            emit(indent, "}");
            
            // add(index, value)
            emit(indent, "public void add"+beanName+"(int index, "+javaType+" value) {");
	    if(isChoice && (omitAll != null)) {
		emit(indent+TAB, "if (_" + javaName + ".size() == 0) {" + omitAll + "}");
	    }
            if(boxedType != null && accessor.length() > 0) {
                emit(indent+TAB, "_"+javaName+".add(index, new "+boxedType+"(value));");
            } else {
                emit(indent+TAB, "_"+javaName+".add(index, value);");
            }
            emit(indent, "}");
            
            // clear
            emit(indent, "public void clear"+beanName+"() {");
            emit(indent+TAB, "_"+javaName+".clear();");
            emit(indent, "}");
            emit(indent, "");
        }
	if(nillable) {
	    emit(indent, "public boolean nil"+beanName+"(int index) {");
	    emit(indent+TAB, "if(_nil_" + javaName + ".size() == index) _nil_" + javaName + ".add(new java.lang.Boolean(false));");
	    emit(indent+TAB, "return ((java.lang.Boolean)_nil_"+javaName+".get(index)).booleanValue();");
	    emit(indent, "}");
	    emit(indent, "public void nil"+beanName+"(int index, boolean value) {");
	    emit(indent+TAB, "get"+beanName+"(index);");
	    emit(indent+TAB, "if(_nil_" + javaName + ".size() == index) _nil_" + javaName + ".add(new java.lang.Boolean(value));");
	    emit(indent+TAB, "else _nil_" + javaName + ".set(index, new java.lang.Boolean(value));");
	    emit(indent, "}");
	}
	emit("", "");
    }
    
    public static String package2Path(String rootDir, String packageName)
    {
        if(packageName == null) return rootDir;
        String fpaths = packageName.replace('.', File.separatorChar);
        fpaths = rootDir+File.separator+fpaths;
        return fpaths;
    }
    
    // LT added
    public void processInit(PrintStream ps, String indent, List l)
    {
        setOut(ps);
        processInit(indent, l);
    }
    
    
    public void processInit(String indent, List l)
    {
        emit(indent, "private void init() {");
        if ( l != null )
        {
            for (int i = 0; i < l.size(); i++)
            {
                String line = (String) l.get(i);
                emit(indent+TAB, line);
            }
        }
        emit(indent, "}");
    }

    // Just take the base name of the file.
    protected String getBaseName(String fileName) 
    {
        int idx;
        
        idx = fileName.lastIndexOf(".dtd");
        if (idx != -1) 
        {
            return fileName.substring(0, idx);
        }
        
        idx = fileName.lastIndexOf(".ssc");
        if (idx != -1) 
        {
            return fileName.substring(0, idx);
        }
        
        idx = fileName.lastIndexOf(".xsd");
        if (idx != -1) 
        {
            return fileName.substring(0, idx);
        }
        
        idx = fileName.lastIndexOf(".idoc");
        if (idx != -1) 
        {
            return fileName.substring(0, idx);
        }
        
        idx = fileName.lastIndexOf(".txt");
        if (idx != -1) 
        {
            return fileName.substring(0, idx);
        }
        
        idx = fileName.lastIndexOf(".");
        if (idx != -1) 
        {
            return fileName.substring(0, idx);
        }
        
        return fileName;
    }

    PrintStream logFile;

    // WARNING!!! It is not appropriate to use this from a subclass because the <etd> node
    // is created with type "dtd".
    public void compile(String infname, String xscfname, String pkg) throws Exception  {
	throw new Exception("Not yet implemented.");
    }

    // *****************************************************************
    // *****************************************************************
    // WARNING!!! DELETES ALL FILES, INLCUDING SUBDIRECTORIES, IN THE
    // SPECIFIED DIRCETORY.
    // *****************************************************************
    // *****************************************************************
    public void deleteDirTree(String rootPath, String pkg) {
	// This method is meant to delete the file generated by the builders
	// and by generateRuntimePackage. For example, if rootPath is "." and
	// pkg is com.sun.foo.test, then the directory ./com.sun is deleted.
	// Other builders use temporary directories for their rootPath so it's
	// also safe to delete them. However, other builders do not, so it's not
	// wise to delete the directory tree because it's possible that another
	// builder is running on another thread with the same rootPath and a
	// package name like com.sun.foo.test2, in which case we only want to delete
	// ./com.sun/foo/test instead of ./com.sun.
	// If all builders used temp directories for their root output directory,
	// we could just do delete(new File(rootPath)) here.
	if (pkg.length() > 0) {
	    File dir = new File(rootPath, pkg.replace('.', File.separatorChar));
	    delete(dir);
	}
    }

    // Delete all the contents of the specified directory, including subdirectories.
    public void delete(File dir) {
        File[] contents = dir.listFiles();
	if(contents != null) {
	    for (int i = 0; i < contents.length; i++) {
		if (contents[i].isDirectory()) {
		    delete(contents[i]);
		} else {
		    if (!contents[i].delete()) {
			System.err.println("Couldn't delete: " + contents[i].getPath());
		    }
		}
	    }
	}
	if (!dir.delete()) {
	    System.err.println("Couldn't delete: " + dir.getPath());
	}
    }

    public void compile(java.net.URL fin, String pkg) throws IOException, SAXException {
	//        throw new IOException("This method must be implemented by the subclass.");
    }

    public void compile(File fin, String pkg) throws IOException, SAXException {
        throw new IOException("This method must be implemented by the subclass.");
    }

    public void generateRuntimePackage(String inputFile, String xscFile, String packageName)
        throws IOException, SAXException 
    {
        generateRuntimePackage(inputFile, xscFile, packageName, false);
    }

    public void generateRuntimePackage(String inputFile, String xscFile, String packageName, boolean keepJavaFiles)
        throws IOException, SAXException 
    {
        generateRuntimePackage(inputFile, xscFile, packageName, keepJavaFiles, true);
    }

    public void generateRuntimePackage(String inputFile,
				       String xscFile,
				       String packageName,
				       boolean keepJavaFiles,
				       boolean includeSourceFilesInJar)
        throws IOException, SAXException {
	generateRuntimePackage(inputFile, xscFile, packageName, keepJavaFiles,
			       includeSourceFilesInJar, false);
    }

    // LT: added
    public void generateRuntimePackage(String inputFile,
				       String xscFile,
				       String packageName,
				       boolean keepJavaFiles,
				       boolean includeSourceFilesInJar,
				       boolean compileInSeparateProcess)
        throws IOException, SAXException {
        File outFile = new File(xscFile);
        File dir = outFile.getParentFile();
        if (dir == null) dir = new File(".");
        //String name = xscFile;
        String rootName = outFile.getName();
        int dot = rootName.lastIndexOf('.');
        if (dot > 0) {
	    rootName = rootName.substring(0, dot);
	}
        run(inputFile, dir.getPath(), rootName, packageName,
	    keepJavaFiles, includeSourceFilesInJar, compileInSeparateProcess);
    }
    
    public String getPath(File f) 
    {
        String result = f.getPath();
        return result.replace('\\', '/');
    }
    
    public void run(String inputFile,
                    String outputDir,
                    String rootName,
                    String outputPkg)
        throws IOException, SAXException 
    {
        run(inputFile, outputDir, rootName, outputPkg, false, true); // LT: added last param
    }

    public static File[] getJavaFiles(File packageDir) {
	return getFiles(packageDir, ".java");
    }

    public static File[] getFiles(File packageDir, String endFilter) {
	LinkedList result = new LinkedList();
	getFiles(packageDir, result, endFilter);
	File[] resultArray = new File[result.size()];
	return (File[])result.toArray(resultArray);
    }

    public static void getFiles(File packageDir, LinkedList result, final String endFilter) {
	File[] subdirs = packageDir.listFiles(new FileFilter() {
		public boolean accept(File f) {
		    return f.isDirectory();
		}
	    });
	for(int i = 0; i < subdirs.length; i++) {
	    getFiles(subdirs[i], result, endFilter);
	}
        File[] fileList = packageDir.listFiles(new FileFilter() {
		public boolean accept(File f) 
		{
		    if ((endFilter == null) || f.getName().endsWith(endFilter)) {
			return true;
		    }
		    return false;
		}
            });
	for(int i = 0; i < fileList.length; i++) {
	    result.add(fileList[i]);
	}
    }

    public void run(String inputFile,
                    String outputDir,
                    String rootName,
                    String outputPkg,
                    boolean keepJavaFiles,
                    boolean includeSourceFilesInJar)
	throws IOException, SAXException {
	run(inputFile, outputDir, rootName, outputPkg, keepJavaFiles,
	    includeSourceFilesInJar, false);
    }
    
    public void run(String inputFile,
                    String outputDir,
                    String rootName,
                    String outputPkg,
                    boolean keepJavaFiles,
                    boolean includeSourceFilesInJar,
		    boolean compileInSeparateProcess)
        throws IOException, SAXException {
	File outDir = new File(outputDir);
        if (outputPkg == null) outputPkg = "";
        String outputPkgFileName = outputPkg.replace('.', File.separatorChar);
        File packageDir = new File(getRootDirectory(), outputPkgFileName);
        // call javac
        
	//esr 55711
	String javacOpt =(String)getProperty("javacOpt");
	System.out.println("javacOpt=" + javacOpt);
	if (javacOpt == null) javacOpt = "";
	StringTokenizer tn = new StringTokenizer(javacOpt, " ");
	if (tn.countTokens() > 0) {
	    compileInSeparateProcess = true;
	}
        
	int k;
	if(compileInSeparateProcess) {
	    k = 8;
	} else {
	    k = 7;
	}
        
	File[] fileList = getJavaFiles(packageDir);
	String[] args = new String[fileList.length + k];

	//esr 55711
	if (tn.countTokens() > 0) {
	    args = new String[tn.countTokens() + k];
	}
        
	String result;
	k = 0;
	if(compileInSeparateProcess) {
	    args[k++] = "javac";
	}

	//esr 55711
	if (tn.countTokens() == 0) {
	  args[k++] = "-g";
        args[k++] = "-classpath";
        args[k++] = System.getProperty("java.class.path");
        args[k++] = "-d";
        args[k++] = getRootDirectory();
        args[k++] = "-sourcepath";
	  args[k++] = getRootDirectory();
        File outputPkgFile = new File(outputPkgFileName);

        int i;
        for (i = 0; i < fileList.length; i++) {
	    args[k++] = getPath(fileList[i]);
        }
	  if(compileInSeparateProcess) {
	    result = execute(args, outDir);
	  } else {
	    result = javac(args);
	  }
 	  if (result != null) {
 	    throw new IOException(result);
 	  }

 	  // LT: added 2 following lines
 	  if (!includeSourceFilesInJar) {
            deleteNonClassFiles(packageDir);
 	  }
 	  File jarFile = new File(outDir, rootName + ".jar");
 	  // call jar
 	  args = new String[] {"cvf", jarFile.getAbsolutePath(), 
                  "-C", getRootDirectory(),
                  outputPkgFileName};
 	  result = jar(args);
 	  if (result != null) {
            throw new IOException(result);
 	  }
	} else {
          String t = null;
          while (tn.hasMoreTokens()) {
              t = tn.nextToken().trim();
              if (t.length() > 0 ) {
                  args[k++] = t;
              }
          }
          args[k++] = "-classpath";
          args[k++] = System.getProperty("java.class.path");
          args[k++] = "-d";
          args[k++] = getRootDirectory();
          args[k++] = "-sourcepath";
	  args[k++] = getRootDirectory();
          
          String sourceFiles = (String)getProperty("sourceFiles");
          if (sourceFiles == null) sourceFiles = "/elements/*.java /types/*.java";
          StringTokenizer tnsf = new StringTokenizer(sourceFiles, " ");
          String tsf = null;
          while (tnsf.hasMoreTokens()) {
              tsf = (String)tnsf.nextToken();
              args[args.length-1] =  getPath(packageDir) + tsf;
	      result = execute(args, outDir);
 	      if (result != null) {
 	          throw new IOException(result);
 	      }
 	  }

 	  File jarFile = new File(outDir, rootName + ".jar");
 	  args = new String[] {"jar", "-cvf", jarFile.getAbsolutePath(), 
                  "-C", getRootDirectory(),
                  outputPkgFileName};
 	  result = execute(args, null);
 	  if (result != null) {
            throw new IOException(result);
 	  }
	}        

        if (!keepJavaFiles) {
            deleteDirTree(rootDir, outputPkgFileName);
        }
    }

    public String execute(String[] args) throws IOException 
    {
        return execute(args, null);
    }

    class StreamReader implements Runnable 
    {
        BufferedReader reader;
        PrintWriter printer;
        IOException exc = null;
        StreamReader(InputStream strm, PrintWriter printer) 
        {
            reader = new BufferedReader(new InputStreamReader(strm));
            this.printer = printer;
        }
        
        public void run() 
        {
            try 
            {
                String line;
                while ((line = reader.readLine()) != null) 
                {
                    printer.println(line);
                }
                printer.flush();
            }
            catch (IOException exc) 
            {
                this.exc =exc;
            }
        }
    }


    public String javac(String[] argv) {
        ByteArrayOutputStream strm = new ByteArrayOutputStream();
        PrintStream logstr = new PrintStream(strm);
        PrintStream out = System.out;
        PrintStream err = System.err;
        int result = 0;
        System.setOut(logstr);
        System.setErr(logstr);
        boolean isJava13 = true;
	
        Class c = null;


        // ESR 52318: 
        // delay compilation for one second to prevent .class and .java
        // files from having the same time stamp.
        try 
          {
            java.lang.Thread.sleep(1000);
          } 
        catch (Exception e) 
          {
            e.printStackTrace();
            result = -1;
          }
        

        try {
            c = Class.forName("com.sun.sun.tools.javac.Main");  // 1.3
        } catch (Exception e) {
            try {
		e.printStackTrace();
                c = Class.forName("sun.tools.javac.Main");  // 1.2
            } catch (Exception e2) {
		result = -1;
		e2.printStackTrace();
            }
            isJava13 = false;
        }

	if(result == 0) {
	    Object compiler = null;
	    Method compile = null;
	    Constructor cons = null;
	    try {
		if(isJava13) {
		    compiler = c.newInstance();
		    compile = c.getMethod("compile", new Class[] {(new String[] {}).getClass ()});
		} else {
		    // Create an instance of the compiler, redirecting output to
		    // byte array stream
		    cons = c.getConstructor(new Class[] { OutputStream.class, String.class });
		    compiler = cons.newInstance(new Object[] { logstr, "javac" });
		    compile = c.getMethod("compile", new Class[] { String[].class });
		}
	    } catch (Exception e) {
		    e.printStackTrace();
	    }
	    
	    try {
		if(isJava13) {
		    result = ((Integer)compile.invoke(compiler, new Object[] {argv})).intValue();
		} else {
		    Boolean ok = (Boolean)compile.invoke(compiler, new Object[] {argv});
		    result = (ok.booleanValue() ? 0 : 1);
		}
	    } catch (Exception exc) {
		exc.printStackTrace();
		result = -2;
	    }
	}

	System.setOut(out);
	System.setErr(err);
	if (result != 0) {
            logstr.flush();
            return "Compiler errors.\n" + new String(strm.toByteArray());
        }

        return null;
    }

    // This only works for creating new JARs.
    // It needs updating to handle other actions: update, extract.
    public String newjar(String[] argv) {
	System.out.println("Creating pkgDir with " + argv[3] + " and " + argv[4]);
	File pkgDir = new File(argv[3], argv[4]);
	File[] files = getFiles(pkgDir, null);
	String pkgPath = argv[4].replace(File.separatorChar, '/');

	try {
	    // Create the manifest.
	    Manifest manifest = new Manifest();
	    manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
	    for(int i = 0; i < files.length; i++) {
		File f = files[i];
		Attributes attr = new Attributes();
		attr.put(new Attributes.Name("Date"), new Date(f.lastModified()).toString());
		manifest.getEntries().put(pkgPath + "/" + f.getName(), attr);
	    }

	    // Create the JAR file.
	    JarOutputStream jos = new JarOutputStream(new FileOutputStream(argv[1]), manifest);
	    byte[] buf = new byte[8192];
	    for(int j = 0; j < files.length; j++) {
		File f = files[j];
		if(!f.isDirectory()) {
		    FileInputStream fis = new FileInputStream(f.getPath().replace(File.separatorChar, '/'));
		    jos.putNextEntry(new JarEntry(pkgPath + "/" + f.getName()));
		    // Read the file and copy it to the JAR file.
		    int len;
		    while((len = fis.read(buf)) >= 0) {
			jos.write(buf, 0, len);
		    }
		    fis.close();
		}
	    }
	    jos.close();
	} catch(Exception e) {
	    e.printStackTrace();
	    return e.getMessage();
	}
	return null;
    }

    // The problem with this is that it does not close the created JAR file.
    public String jar(String[] argv) 
    {
        System.out.println("Jar/argv");
        for (int i=0; i<argv.length; i++) {
            System.out.println(argv[i]);   
        }
        ByteArrayOutputStream strm = new ByteArrayOutputStream();
        PrintStream logstr = new PrintStream(strm);
        PrintStream out = System.out;
        PrintStream err = System.err;
        int result = 0;

        System.setOut(logstr);
        System.setErr(logstr);
        try 
        {
            Class c = Class.forName ("sun.tools.jar.Main");
            //Object compiler = null; // c.newInstance ();
            Constructor ctor = c.getConstructor (new Class[] {java.io.PrintStream.class,
                                                 java.io.PrintStream.class,
                                                 String.class});
            Object compiler = 
                             ctor.newInstance(new Object[] {System.out, System.err, "jar"});
            //Object compiler = null; // c.newInstance ();
            Method compile = c.getMethod ("run",
                                          new Class[] {(new String[] {}).getClass ()});
            result = (((Boolean) compile.invoke
                (compiler, new Object[] {argv})).booleanValue()) ? 0 : 1;
        }
        catch (Exception exc) 
        {
            exc.printStackTrace(logstr);
            result = 1;
        }
        System.setOut(out);
        System.setErr(err);
        if (result != 0) 
        {
            logstr.flush();
            return new String(strm.toByteArray());
        }
        return null;
    }

    public String execute(String[] args, File cwd) throws IOException 
    {
        System.out.println("execute/args");
        for (int i=0; i<args.length; i++) {
            System.out.println(args[i]);   
        }
        Process process = Runtime.getRuntime().exec(args);
        InputStream stdout = process.getInputStream();
        InputStream stderr = process.getErrorStream();
        StringWriter output = new StringWriter();
        StringWriter err = new StringWriter();
        PrintWriter printer1 = new PrintWriter(output);
        PrintWriter printer2 = new PrintWriter(err);
        StreamReader s1, s2;
        Thread t1 = new Thread(s1 = new StreamReader(stdout, printer1));
        Thread t2 = new Thread(s2 = new StreamReader(stderr, printer2));
        t1.start();
        t2.start();
        int status = 0;
        try 
        {
            status = process.waitFor();
        }
        catch (InterruptedException exc) 
        {
            status = 1;
        }
        try 
        {
            t1.join();
        }
        catch (InterruptedException exc) 
        {
            status = 1;
        }
        try 
        {
            t2.join();
        }
        catch (InterruptedException exc) 
        {
            status = 1;
        } 
        if (s1.exc != null) 
        {
            throw s1.exc;
        }
        if (s2.exc != null) 
        {
            throw s2.exc;
        }
        StringBuffer buf = new StringBuffer();
        buf.append(output.toString());
        buf.append('\n');
        buf.append(err.toString());
        //    if (status != 0) {
        //        System.out.println("status : " + status);
        //    }
        //    if (true) {
        //        System.err.println(buf.toString());  
        //    }
        return (status != 0) ? buf.toString() : null;
    }

    // This is designed to be called from our VB code using JIntegra because String[] is
    // not supported in VB.
    // Assumes that args is comma-separated.
    public String vbjavac(String args) {
 	StringTokenizer tokens = new StringTokenizer(args, ",");
 	String[] argv = new String[tokens.countTokens()];
 	int i = 0;
	
 	while (tokens.hasMoreTokens()) {
 	    argv[i++] = tokens.nextToken().trim();
 	}
 	return javac(argv);
    }

    // This is designed to be called from our VB code using JIntegra because String[] is
    // not supported in VB.
    // Assumes that args is comma-separated.
    public String vbjar(String args) {
	StringTokenizer tokens = new StringTokenizer(args, ",");
	String[] argv = new String[tokens.countTokens()];
 	int i = 0;
	
 	while (tokens.hasMoreTokens()) {
 	    argv[i++] = tokens.nextToken().trim();
 	}
	
  	return jar(argv);
    }

    // LT: added
    private void deleteNonClassFiles(File dir) 
    {
        File[] contents = dir.listFiles();
        for (int i = 0; i < contents.length; i++) 
        {
            if (contents[i].isDirectory()) 
            {
                delete(contents[i]);
            }
            else 
            {
                String filename = contents[i].getName();
                //System.err.println("filename: "+filename);
                if (!filename.endsWith(".class")) 
                {
                    if (!contents[i].delete()) 
                    {
                        System.err.println("Couldn't delete: " + contents[i].getPath());
                    }
                }
            }
        }
    }
    
    private void emitClassHeader(String indent, String[] impPackages, String pkg, String className,
                                 String inheritance, String[] interfaces, String javadocCmt)
    {
        if (pkg != null)
        {
            emit(indent, "package "+pkg+";");
        }
        
        if (impPackages != null)
        {
            for (int i = 0; i < impPackages.length; i++)
            {
                emit(indent, "import "+impPackages[i]+";");
            }
        }
        
        emit(indent, "");
        emit(indent, "// WARNING: This class file is machine-generated!  Please do not alter");
        emit(indent, "// it manually without a comprehensive understanding of its logic.");
        emit(indent, "");

		if (javadocCmt != null && javadocCmt.trim().length() > 0)
		{
			emit(indent, javadocCmt);
		}
		
        emit(indent, "public class " + className +(inheritance == null ?"":" "+inheritance));
        if (interfaces != null)
        {
            emit(indent, TAB+"implements ");
            for (int i = 0; i < interfaces.length; i++)
            {
                emit(indent, TABTAB+(i > 0 ? "," : " ")+interfaces[i]);
            }
        }
        
        emit(indent, "{");
    }
    
    protected PrintStream generateClassHeader(String indent, String[] impPackages, String pkg,
                                              String className, String inheritance, String rootDir)
        throws IOException
    {
        return generateClassHeader(indent, impPackages, pkg, className, inheritance, rootDir, null, null);
    }
     
    protected PrintStream generateClassHeader(String indent, String[] impPackages, String pkg,
                                              String className, String inheritance, String rootDir,
                                              String[] interfaces)
		throws IOException
	{
        return generateClassHeader(indent, impPackages, pkg, className, inheritance, rootDir, interfaces, null);
	}
   
    protected PrintStream generateClassHeader(String indent, String[] impPackages, String pkg,
                                              String className, String inheritance, String rootDir,
                                              String[] interfaces, String javadocCmt)
        throws IOException
    {
        PrintStream pstream = createPrintStream(package2Path(rootDir, pkg), className+".java");
        setOut(pstream);
        emitClassHeader(indent, impPackages, pkg, className, inheritance, interfaces, javadocCmt);
        return pstream;
    }

    // Generates the class header -- output stream already set.
    protected void generateClassHeader(String indent, String[] impPackages, String pkg,
                                       String className, String inheritance)
    {
        emitClassHeader(indent, impPackages, pkg, className, inheritance, null, null);
    }
    
    protected void generateClassHeader(String indent, String[] impPackages, String pkg,
                                       String className, String inheritance, String[] interfaces)
    {
        emitClassHeader(indent, impPackages, pkg, className, inheritance, interfaces, null);
    }
    
    protected void generateClassHeader(String indent, String[] impPackages, String pkg, String className,
                                       String inheritance, String[] interfaces, String javadocCmt)
    {
        emitClassHeader(indent, impPackages, pkg, className, inheritance, interfaces, javadocCmt);
    }
    
    protected void emitSubSetSimpleETDImpl(String indent)
    {
        /** ESR54048  Let SimpleETDImpl keep track of these variables.
        emit(indent, "protected JCollabController __jcollabController = null;");
        emit(indent, "protected java.lang.String __key = null;");
        emit(indent, "protected int __mode;");
        emit(indent, "protected boolean __dataAvailable = false;");
        emit(indent, "");
         **/
        emit(indent, "public void "+ETDConstants.INITIALIZE+"(JCollabController jcollabCcontroller, java.lang.String key, int mode)");
        emit(indent+TAB, "throws CollabConnException, CollabDataException {");
        emit(indent+TAB, "__jcollabController = jcollabCcontroller;");
        emit(indent+TAB, "__key = key;");
        emit(indent+TAB, "__mode = mode;");
        emit(indent, "}");
        emit(indent, "public java.lang.String "+ETDConstants.GETKEY+"() {");
        emit(indent+TAB, "return __key;");
        emit(indent, "}");
        emit(indent, "public int "+ETDConstants.GETMODE+"() {");
        emit(indent+TAB, "return __mode;");
        emit(indent, "}");
        emit(indent, "public void "+ETDConstants.TERMINATE+"()");
        emit(indent+TAB, "throws CollabConnException {");
        emit(indent, "}");
        emit(indent, "public boolean "+ETDConstants.RESET+"() {");
        emit(indent+TAB, "__inputMessages = null;");
        emit(indent+TAB, "__dataAvailable = false;");
        emit(indent+TAB, "init();"); // Added to reset etds. ESR 52607.
        emit(indent+TAB, "return true;"); // Return value changed to true as fields are reset. ESR 52607.
        emit(indent, "}");  
        emit(indent, "public boolean "+ETDConstants.HASDATA+"() {");
        emit(indent+TAB, "return __dataAvailable;");
        emit(indent, "}");
        emit(indent, "protected java.util.Enumeration __inputMessages = null;");
        emit(indent, "protected JMsgObject __jMsgObject = null;");
        emit(indent, "public boolean "+ETDConstants.GETNEXTSRCEVENT+"() throws CollabDataException {");
        emit(indent+TAB, "__dataAvailable = false;");
        emit(indent+TAB, "if (__jcollabController != null) {");
        emit(indent+TABTAB, "if (__inputMessages == null) {");
        emit(indent+TABTABTAB, "__inputMessages = __jcollabController.getInputMessages("+ETDConstants.GETKEY+"());");
        emit(indent+TABTAB, "}");
        emit(indent+TABTAB, "if (__inputMessages.hasMoreElements()) {");
        emit(indent+TABTABTAB, "__jMsgObject = (JMsgObject)__inputMessages.nextElement();");
        emit(indent+TABTABTAB, "unmarshal(__jMsgObject.getData());");
        emit(indent+TABTABTAB, "__dataAvailable = true;");
        emit(indent+TABTAB, "}");
        emit(indent+TAB, "}");
        emit(indent+TAB, "return __dataAvailable;");
        emit(indent, "}");
        emit(indent, "public void "+ETDConstants.IQPUT+"() throws CollabDataException {");
        emit(indent+TAB, "if (__jcollabController != null) {");
        emit(indent+TABTAB, "__jcollabController.publishToAllFor(" + ETDConstants.GETKEY + "(), null, marshal());");
        emit(indent+TAB, "}");
        emit(indent, "}");
        emit(indent, "public void "+ETDConstants.IQPUT+"(java.lang.String topicName) throws CollabDataException {");
        emit(indent, "}");
        emit(indent, "public boolean "+ETDConstants.IQGET+"() throws CollabDataException {");
        emit(indent+TAB, "return false;");
        emit(indent, "}");
        emit(indent, "public boolean "+ETDConstants.IQGET+"(java.lang.String topicName) throws CollabDataException {");
        emit(indent+TAB, "return false;");
        emit(indent, "}");
        emit(indent, "public byte[] "+ETDConstants.RAWINPUT+"() throws CollabDataException {");
        emit(indent+TAB, "byte[] rawDat = null;");
        emit(indent+TAB, "if (__jMsgObject != null) {");
        emit(indent+TABTAB, "rawDat = __jMsgObject.getData();");
        emit(indent+TAB, "}");
        emit(indent+TAB, "return rawDat;");
        emit(indent, "}");
        emit(indent, "public java.lang.String "+ETDConstants.TOPIC+"() throws CollabDataException {");
        emit(indent+TAB, "java.lang.String topic = null;");
        emit(indent+TAB, "if (__jMsgObject != null) {");
        emit(indent+TABTAB, "topic = __jMsgObject.getJTopic().getName();");
        emit(indent+TAB, "}");
        emit(indent+TAB, "return topic;");
        emit(indent, "}");
        emit(indent, "public java.util.Vector "+ETDConstants.PUBLICATIONS+"() throws CollabDataException {");
        emit(indent+TAB, "return null;");
        emit(indent, "}");
        emit(indent, "public java.util.Vector "+ETDConstants.SUBSCRIPTIONS+"() throws CollabDataException {");
        emit(indent+TAB, "return null;");
        emit(indent, "}");
    }

    public void generateClassMethods() throws SAXException {
	generateClassMethods(xscWriter);
    }

    public void generateClassMethods(XscWriter sw) throws SAXException {

	// reset
	sw.emptyMethodElement(ETDConstants.RESET, ETDConstants.RESET_SIG, "boolean", JCSConstants.resetMethodComment);

	// available
        sw.emptyMethodElement(ETDConstants.HASDATA, ETDConstants.HASDATA_SIG, "boolean", JCSConstants.availableMethodComment);

	// next
        sw.startMethodElement(ETDConstants.GETNEXTSRCEVENT, ETDConstants.GETNEXTSRCEVENT_SIG, "boolean", JCSConstants.nextMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, JCSConstants.collabDataExceptionComment);
	sw.endMethodElement();

	// receive
        sw.startMethodElement(ETDConstants.IQGET, ETDConstants.IQGET_SIG, "boolean", JCSConstants.receiveMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, JCSConstants.collabDataExceptionComment);
	sw.endMethodElement();

	// receive
	sw.startMethodElement(ETDConstants.IQGET, ETDConstants.IQGET_SIG2, "boolean", JCSConstants.receiveMethodComment);
        sw.emptyParamElement("topicName", "java.lang.String", JCSConstants.topicNameParamComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, JCSConstants.collabDataExceptionComment);
	sw.endMethodElement();

	// send
	sw.startMethodElement(ETDConstants.IQPUT, ETDConstants.IQPUT_SIG, "void", JCSConstants.sendMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, JCSConstants.collabDataExceptionComment2);
	sw.endMethodElement();

	// send
	sw.startMethodElement(ETDConstants.IQPUT, ETDConstants.IQPUT_SIG2, "void", JCSConstants.sendMethodComment);
        sw.emptyParamElement("topicName", "java.lang.String", JCSConstants.topicNameParamComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, JCSConstants.collabDataExceptionComment2);
	sw.endMethodElement();

	// rawInput
	sw.startMethodElement(ETDConstants.RAWINPUT, ETDConstants.RAWINPUT_SIG, "byte[]", JCSConstants.rawInputMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, null);
	sw.endMethodElement();

	// topic
	sw.startMethodElement(ETDConstants.TOPIC, ETDConstants.TOPIC_SIG, "java.lang.String", JCSConstants.topicMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, null);
	sw.endMethodElement();

	// publications
	sw.startMethodElement(ETDConstants.PUBLICATIONS, ETDConstants.PUBLICATIONS_SIG, "java.util.Vector", JCSConstants.publicationsMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, null);
	sw.endMethodElement();

	// subscriptions
	sw.startMethodElement(ETDConstants.SUBSCRIPTIONS, ETDConstants.SUBSCRIPTIONS_SIG, "java.util.Vector", JCSConstants.subscriptionsMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.collabDataExceptionClass, null);
	sw.endMethodElement();

	// marshal
	sw.startMethodElement(ETDConstants.MARSHAL, ETDConstants.MARSHAL_SIG, "byte[]", JCSConstants.marshalMethodComment);
	//	sw.emptyThrowsElement(JCSConstants.marshalExceptionClass, JCSConstants.marshalExceptionComment);
	sw.endMethodElement();

	// unmarshal
	sw.startMethodElement(ETDConstants.UNMARSHAL, ETDConstants.UNMARSHAL_SIG, "void", JCSConstants.unmarshalMethodComment);
        sw.emptyParamElement("blob", "byte[]", JCSConstants.blobParamComment);
	//	sw.emptyThrowsElement(JCSConstants.unmarshalExceptionClass, JCSConstants.unmarshalExceptionComment);
	sw.endMethodElement();

	// readProperty
        sw.startMethodElement(ETDConstants.READPROPERTY, ETDConstants.READPROPERTY_SIG, "java.lang.String", JCSConstants.readPropertyMethodComment);
        sw.emptyParamElement("propName", "java.lang.String", JCSConstants.readPropNameParamComment);
        sw.endMethodElement();

	// writeProperty
        sw.startMethodElement(ETDConstants.WRITEPROPERTY, ETDConstants.WRITEPROPERTY_SIG, "void", JCSConstants.writePropertyMethodComment);
        sw.emptyParamElement("propName", "java.lang.String", JCSConstants.writePropNameParamComment);
        sw.emptyParamElement("propValue", "java.lang.String", JCSConstants.writePropValueParamComment);
        sw.endMethodElement();
    }

    /**
     * Must give fully qualified name, i.e., java.lang.String not just String.
     * If array, there must no spaces between the type and [], e.g., int[].
     */
    public static String typeSignature(String name) {
	// Do primitive types.
	if(name.equals("void")) return "V";
	else if(name.equals("int")) return "I";
	else if(name.equals("boolean")) return "Z";
	else if(name.equals("byte[]")) return "[B";
	else if(name.equals("byte")) return "B";
	else if(name.equals("char")) return "C";
	else if(name.equals("short")) return "S";
	else if(name.equals("long")) return "J";
	else if(name.equals("float")) return "F";
	else if(name.equals("double")) return "D";
	else if(name.equals("int[]")) return "[I";
	else if(name.equals("boolean[]")) return "[Z";
	else if(name.equals("char[]")) return "[C";
	else if(name.equals("short[]")) return "[S";
	else if(name.equals("long[]")) return "[J";
	else if(name.equals("float[]")) return "[F";
	else if(name.equals("double[]")) return "[D";

	// Assume fully-qualified type name.
	String sig = "";
	boolean isArray = false;
	if(name.endsWith("[]")) {
	    isArray = true;
	    sig += "[";
	    name = name.substring(0, name.length()-2);
	}
	name = name.replace('.', '/');
	sig += "L";
	sig += name;
	sig += ";";

	return sig;
    }

    public static String methodSignature(String name, String returnType, String[] paramNames) {
	String sig = name;
	sig += "(";
	if(paramNames != null) {
	    for(int k = 0; k < paramNames.length; k++) {
		sig += typeSignature(paramNames[k]);
	    }
	}
	sig += ")";
	sig += typeSignature(returnType);
	//	System.out.println("methodSignature: " + sig);
	return sig;
    }

    public static void addExtraMethodElements(XscWriter sw, String beanName, String returnType,
					  int card, boolean inChoice) {
	if(card == OPTIONAL || inChoice) {
	    // has 
	    sw.emptyMethodElement("has"+beanName,
					 methodSignature("has"+beanName, "boolean", null),
					 "boolean", 
					 "test if element is present");
	    // omit
	    sw.emptyMethodElement("omit"+beanName,
					 methodSignature("omit"+beanName, "void", null),
					 "void", 
					 "omit element");
	}

	if(card == ZEROMANY || card == ONEMANY) {
/*
	    // set
	    sw.startMethodElement("set"+beanName,
					 methodSignature("set"+beanName, "void",
							 new String[] {"int", returnType}),
					 "void", 
					 "set element at index");
	    sw.emptyParamElement("index", "int", "");
	    sw.emptyParamElement("value", returnType, "set element at index");
	    sw.endElement();
	    // get
	    sw.startMethodElement("get"+beanName,
					 methodSignature("get"+beanName, returnType,
							 new String[] {"int"}),
					 returnType, 
					 "get element at index");
	    sw.emptyParamElement("index", "int", "");
	    sw.endElement();
*/
	    // add
	    sw.startMethodElement("add"+beanName,
					 methodSignature("add"+beanName, "void",
							 new String[] {returnType}),
					 "void", 
					 "append element");
	    sw.emptyParamElement("value", returnType, "");
	    sw.endElement();
	    sw.startMethodElement("add"+beanName,
					 methodSignature("add"+beanName, "void",
							 new String[] {"int", returnType}),
					 "void", 
					 "insert element at index");
	    sw.emptyParamElement("index", "int", "");
	    sw.emptyParamElement("value", returnType, "");
	    sw.endElement();
	    // remove
	    sw.startMethodElement("remove"+beanName,
					 methodSignature("remove"+beanName, "void",
							 new String[] {"int"}),
					 "void", 
					 "delete element at index");
	    sw.emptyParamElement("index", "int", "");
	    sw.endElement();
	    // count
	    sw.emptyMethodElement("count"+beanName,
					 methodSignature("count"+beanName, "int", null),
					 "int", 
					 "return element count");
	    // clear
	    sw.emptyMethodElement("clear"+beanName,
					 methodSignature("clear"+beanName, "void", null),
					 "void", 
					 "remove all elements");
	}
    }

    public void callAntlrTool(String opath, String gname) throws IOException
    {
        // It seems Antlr is not closing all the files. It didn't need to
        // before because it was doing a System.exit() at the end which
        // effectively closes the files. But for it to work within our
        // code, we had to hack Antlr and remove the System.exit() call
        // at the end, which means the .g file is not closed. This causes
        // a problem when our code is called from the VB wizard. After
        // all is said and done, the VB wizard tries to delete the generated
        // files including the .g file, but it can't because the Java VM is
        // still active and the .g file wasn't closed. So, for now, I'm just
        // execing the Antlr tool as a separate process so when it is finished,
        // the process/Java VM is finished and the file is closed. It turns out that
        // we didn't need to hack Antlr after all. --Rico
        //System.err.println("Calling antlr with " + opath + " " + gname);
        //AntlrTool theTool = new AntlrTool();
        //System.err.println("created antlrtool, before processsource");
        //theTool.processSource(opath, gname);
        //theTool = null;
        //String cmdLine = "java.exe antlr.Tool -o " + opath + " " + opath+File.separator+gname;
        //System.err.println(cmdLine);
        
        String[] cmdLine = 
        {
            "javaw", 
            "-classpath",
            System.getProperty("java.class.path"),
            JCSProperties.getProperty("JGen.antlr", "antlr")+".Tool",
            "-o",
            opath,
            opath + "/" + gname
        };
        String result = null;
        String JCmdOpt =(String)getProperty("JCmdOpt");
        System.out.println("JCmdOpt=" + JCmdOpt);
        if ((JCmdOpt != null) && JCmdOpt.length() > 0 ) {
            StringTokenizer tn = new StringTokenizer(JCmdOpt, "-");
            String[] cmdLineJCmdOpt = new String[7 + tn.countTokens()];
            int i = 0;
            cmdLineJCmdOpt[i] = "javaw";
            
            String t = null;
            while (tn.hasMoreTokens()) {
                t = tn.nextToken().trim();
                if (t.length() > 0 ) {
                    i++;
                    cmdLineJCmdOpt[i] = "-" + t;
                }
            }
            
            i++;
            cmdLineJCmdOpt[i] = "-classpath";
            
            i++;
            cmdLineJCmdOpt[i] = System.getProperty("java.class.path");
            
            i++;
            cmdLineJCmdOpt[i] = JCSProperties.getProperty("JGen.antlr", "antlr")+".Tool";
            
            i++;
            cmdLineJCmdOpt[i] = "-o";
            
            i++;
            cmdLineJCmdOpt[i] = opath;
            
            i++;
            cmdLineJCmdOpt[i] = opath + "/" + gname;
            
            result = execute(cmdLineJCmdOpt);
        } else {
            result = execute(cmdLine);
        }
        if (result != null) 
        {
            throw new IOException(result);
        }
    }

    protected void generateXSCNode(String nname, String min, String max,
                                   String jtype, String uid)
        throws SAXException 
    {
        String tagName = "node";
        AttributesImpl attrs = new AttributesImpl();
        attrs.addAttribute("", "name", "name", "CDATA", normalSafe(nname));
        attrs.addAttribute("", "minOccurs", "minOccurs", "CDATA", min);
        attrs.addAttribute("", "maxOccurs", "maxOccurs", "CDATA", max);
        attrs.addAttribute("", "type", "type", "CDATA", jtype);
        attrs.addAttribute("", "uid", "uid", "CDATA", uid);
        ((SAX2Writer)xscHandler).emptyElement("", tagName, tagName, attrs);
    }

    protected void generateXSCNode(String nname, String optional, String min, String max,
                                   String jtype, String uid)
        throws SAXException 
    {
        String tagName = "node";
        AttributesImpl attrs = new AttributesImpl();
        attrs.addAttribute("", "name", "name", "CDATA", normalSafe(nname));
        attrs.addAttribute("", "optional", "optional", "CDATA", optional);
        attrs.addAttribute("", "minOccurs", "minOccurs", "CDATA", min);
        attrs.addAttribute("", "maxOccurs", "maxOccurs", "CDATA", max);
        attrs.addAttribute("", "type", "type", "CDATA", jtype);
        attrs.addAttribute("", "uid", "uid", "CDATA", uid);
        ((SAX2Writer)xscHandler).emptyElement("", tagName, tagName, attrs);
    }

    protected void generateXSCNode(String nname, String jName,
                                   String optional, String min, String max,
                                   String jtype, String uid)
        throws SAXException 
    {
        String tagName = "node";
        AttributesImpl attrs = new AttributesImpl();
        attrs.addAttribute("", "name", "name", "CDATA", normalSafe(nname));
        attrs.addAttribute("", "javaName", "javaName", "CDATA", jName);
        if (!optional.equals("false")) attrs.addAttribute("", "optional", "optional", "CDATA", optional);
        if (!min.equals("1")) attrs.addAttribute("", "minOccurs", "minOccurs", "CDATA", min);
        if (!max.equals("1")) attrs.addAttribute("", "maxOccurs", "maxOccurs", "CDATA", max);
        attrs.addAttribute("", "type", "type", "CDATA", jtype);
        attrs.addAttribute("", "uid", "uid", "CDATA", uid);
        ((SAX2Writer)xscHandler).emptyElement("", tagName, tagName, attrs);
    }

    // className must come from makeClassName()
    public static String toInstanceName(String className)
    {
        char ch = className.charAt(0);
        String rStr = null;
        if ('_' == ch || Character.isLowerCase(ch))
        {
            rStr = "i"+className;
        }
        else
        {
            rStr = makeRuleName(className);
        }
        return rStr;
    }

    /**
     * Returns whether the specified type is primitive,
     * i.e. boolean, byte, char, double, float, int, long, or short.
     *
     * @param _type string containing the type
     * @return true if the type is primitive,
     * false if it is null or not a primitive.
     * @see #PRIMITIVE_TYPES;
     */
    public static boolean isPrimitiveType (String _type) {
        if(null == _type) return false;
	return (-1 < PRIMITIVE_TYPES.indexOf(_type));
    }

    /**
     * Returns whether the specified type is numeric,
     * i.e. byte, double, float, int, long, or short.
     *
     * @param _type string containing the type
     * @return true if the type is numeric primitive,
     * false if it is null or not a numeric primitive.
     * @see #NUMERIC_TYPES;
     */
    public static boolean isNumericType (String _type) {
        if(null == _type) return false;
	return (-1 < NUMERIC_TYPES.indexOf(_type));
    }

    public static void main(String[] args)
    {
        for (int i = 0; i < args.length; i++)
        {
            System.out.println("("+args[i]+")==>("+JCSCompiler.makePackageName(args[i])+")");
        }
    }
}
