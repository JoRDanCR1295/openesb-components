/*******************************************************************************
 *  Copyright (c) 2005, 2006, 2007 Imola Informatica.
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the LGPL License v2.1
 *  which accompanies this distribution, and is available at
 *  http://www.gnu.org/licenses/lgpl.html
 *******************************************************************************/
package it.imolinfo.jbi4ejb.webservice.generator.bcm;

import it.imolinfo.jbi4ejb.Logger;
import it.imolinfo.jbi4ejb.LoggerFactory;
import it.imolinfo.jbi4ejb.jbi.Messages;
import it.imolinfo.jbi4ejb.webservice.generator.DynamicEJBWSDLGenerator;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassAdapter;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;


/**
 * Adds the correct managed exception to the remote interface.
 * 
 * @author <a href="mailto:mpiraccini@imolinfo.it">Marco Piraccini</a>
 */
public class RemoteInterfaceExceptionAdapter extends ClassAdapter {

    /** The logger. */
    private static final Logger LOG
    = LoggerFactory.getLogger(RemoteInterfaceExceptionAdapter.class); 
    private static final Messages MESSAGES
    = Messages.getMessages(RemoteInterfaceExceptionAdapter.class);

    /** The class loader. */
    private final ClassLoader classLoader;

    /** the exceptions added to the interface. */
    private final List<String> exceptionsAdded = new ArrayList<String>();

    /**
     * Constructor.
     * 
     * @param arg0
     *            The <code>ClassVisitor</code>
     * @param classLoader
     *            The classLoader
     */
    public RemoteInterfaceExceptionAdapter(ClassVisitor arg0, ClassLoader classLoader) {
        super(arg0);    
        this.classLoader = classLoader;
    }

    
    /**
     * Look for the Exception wrapped by the
     * <code>org.codehaus.xfire.fault.FaultInfoException</code> classes
     * generated by WSDL.
     * 
     * @param access
     *            The access modifier
     * @param name
     *            The method name
     * @param desc
     *            The description
     * @param signature
     *            The method signature
     * @param exceptions
     *            The throwed exceptions
     * 
     * @return
     *          The MethodVisitor
     * @see org.objectweb.asm.ClassAdapter#visitMethod(int, java.lang.String,
     *      java.lang.String, java.lang.String, java.lang.String[])
     */
    @SuppressWarnings("unchecked")
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {


        List<String> newExceptions = new ArrayList<String>();
        
        if (exceptions != null) {
            for (int i = 0; i < exceptions.length; i++) {

                String exception = exceptions[i];
                String exceptionName = exception.replace('/', '.');
                LOG.debug("Exception found in method " + name + ": "+ exceptionName);

                Class myExceptionClass = null;
                try {
                    myExceptionClass = classLoader.loadClass(exceptionName);
                } catch (ClassNotFoundException e) {
                	LOG.warn("EJB001101_Exception_in_rethrowing_exception", new Object[]{e.getMessage()});
                }

                if (myExceptionClass != null) {              
                    // Tests if the exception class is a FaultInfoException
                    if (myExceptionClass.getGenericSuperclass().equals(org.codehaus.xfire.fault.FaultInfoException.class)) {
                        LOG.debug("The exception: " + exceptionName + " is a FaultInfoException");
                    }              
                    Method getFaultInfoMethod = null;
                    try {
                        // Gets the getFaultInfom method
                        getFaultInfoMethod = myExceptionClass.getMethod("getFaultInfo", new Class[]{});
                    } catch (SecurityException e) {
                        LOG.warn("EJB001101_Exception_in_rethrowing_exception", new Object[]{e.getMessage()});
                    } catch (NoSuchMethodException e) {
                        LOG.warn("EJB001101_Exception_in_rethrowing_exception", new Object[]{e.getMessage()});
                    }
                    if (getFaultInfoMethod != null) {
                        Class returnType = getFaultInfoMethod.getReturnType();                       
                        String exceptionInternalName = returnType.getName().replace('.', '/');
                        // LOG.debug("Find the return type (internal name): " + exceptionInternalName);
                        newExceptions.add(exceptionInternalName);
                        // Saves all the exceptions names
                        if (!exceptionsAdded.contains(returnType.getName())) {
                            exceptionsAdded.add(returnType.getName());
                        }
                    }                           
                }          
            }
        }

        String[] newExceptionsArray = newExceptions.toArray(new String[0]);
        for (int i = 0; i < newExceptionsArray.length; i++) {
            LOG.debug("modifiying the method " + name + " with the exception: " + newExceptionsArray[i]);    
        }           

        return super.visitMethod(access, name, desc, signature, newExceptionsArray);
    }


    /**
     * Gets the exceptions added to the interface.
     * 
     * @return the exceptions added
     */
    public List<String> getExceptionsAdded() {
        return exceptionsAdded;
    }


}


